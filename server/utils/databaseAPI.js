import mysql from "mysql";
import mysqlutils from "mysql-utilities";
import * as fs from "fs";
import pluralize from "pluralize";
import { camelCaseToLabel } from "../../frontend/src/shared.js";
import sqlite3 from "sqlite3";
import { open } from "sqlite";

const USE_SQLITE = (process.env.DB_TYPE === "sqlite" || process.env.DB_CLIENT === "sqlite" || !!process.env.SQLITE_DB);

// ---------------------------------------------------------------------------
// Input validation helpers – block SQL injection at the boundary.
// ---------------------------------------------------------------------------

// All tables the API is allowed to touch. Requests for any other table name
// are rejected before a query is ever constructed.
const ALLOWED_TABLES = new Set([
  "vendor", "vendors",
  "orderStatus", "orderStatuses",
  "shippingCarrier", "shippingCarriers",
  "customer", "customers",
  "inventory",
  "order", "orders",
  "orderItem", "orderItems",
  "canWeight", "canWeights",
]);

const validateTable = (table) => {
  if (!ALLOWED_TABLES.has(table)) {
    throw new Error(`Table '${table}' is not allowed.`);
  }
  return table;
};

// Accepts plain field names ("vendorId") and SQL aliases used internally
// ("id as 'value'", "name as 'data-text'").
const validateField = (field) => {
  if (!/^[a-zA-Z_][a-zA-Z0-9_]*(\s+as\s+'[a-zA-Z0-9_-]+')?$/.test(field.trim())) {
    throw new Error(`Field '${field}' is not in a safe format.`);
  }
  return field;
};

// WHERE clauses in this app are always of the form `fieldName=integerValue`
// (generated by DataGrid for subgrid FK filtering). Anything else is rejected.
const validateWhere = (where) => {
  if (where === null || where === undefined) return where;
  if (!/^[a-zA-Z_][a-zA-Z0-9_]*=\d+$/.test(where)) {
    throw new Error(`WHERE clause '${where}' is not in a safe format.`);
  }
  return where;
};

// ---------------------------------------------------------------------------
// Database connection setup
// ---------------------------------------------------------------------------

let connection = null;
// Resolved to the open sqlite db instance; awaited inside each function so
// callers never race against the async open().
let sqliteDbPromise = null;

if (USE_SQLITE) {
  const dbPath = process.env.SQLITE_DB || "./mapequipment.db";
  sqlite3.verbose();
  sqliteDbPromise = open({ filename: dbPath, driver: sqlite3.Database });
} else {
  const connectionDetails = {
    host: process.env.DB_ENDPOINT,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: "mapequipment",
    ssl: undefined,
  };

  const caPath = "certs/ca.pem";
  if (fs.existsSync(caPath)) {
    connectionDetails.ssl = { ca: fs.readFileSync(caPath) };
  }

  connection = mysql.createConnection(connectionDetails);
  mysqlutils.upgrade(connection);
  mysqlutils.introspection(connection);
}

// ---------------------------------------------------------------------------
// Public API
// ---------------------------------------------------------------------------

/**
 * Get the field details for the entered table.
 * @param  {String} table required
 * @param  {[String]} fields=null  (unused – kept for API compatibility)
 */
export const fetchFields = async (table, fields = null) => {
  validateTable(table);

  if (USE_SQLITE) {
    const db = await sqliteDbPromise;
    // Table name is whitelisted above so interpolation is safe here.
    const rows = await db.all(`PRAGMA table_info(${table})`);
    const converted = rows.map((r) => ({
      Field: r.name,
      Type: r.type || "text",
      Null: r.notnull === 0 ? "YES" : "NO",
    }));
    return formatFields(converted);
  }

  return new Promise((resolve, reject) => {
    connection.fields(table, (error, fields) => {
      if (error) {
        reject(error);
      } else if (fields) {
        resolve(formatFields(fields));
      }
    });
  });
};

/**
 * Query the database with optional pagination.
 * @param {String} table
 * @param {[String]} fields=null
 * @param {String} where=null  Must be in the form `fieldName=integerValue`.
 * @param {Number} page=null
 */
export const fetchData = async (table, fields = null, where = null, page = null) => {
  validateTable(table);
  const safeWhere = validateWhere(where);

  const pageSize = 100;
  const pageNum = Number(page) || 1;
  const offset = (pageNum - 1) * pageSize;
  const whereClause = safeWhere ? `WHERE ${safeWhere}` : "";

  let fieldList = "*";
  if (fields) {
    const arr = Array.isArray(fields) ? fields : [fields];
    fieldList = arr.map(validateField).join(", ");
  }

  if (USE_SQLITE) {
    const db = await sqliteDbPromise;
    const countSQL = `(SELECT COUNT(id) FROM ${table} ${whereClause}) as count`;
    const sql = `SELECT ${fieldList}, ${countSQL} FROM ${table} ${whereClause} LIMIT ${pageSize} OFFSET ${offset}`;
    return db.all(sql);
  }

  return new Promise((resolve, reject) => {
    const countSQL = `(SELECT COUNT(id) FROM ${table} ${whereClause}) as count`;
    const sqlStatement = `SELECT ${fieldList}, ${countSQL} FROM ${table} ${whereClause} LIMIT ${pageSize} OFFSET ${offset}`;
    connection.query(sqlStatement, (error, results) => {
      if (error) reject(error);
      else resolve(results);
    });
  });
};

/**
 * Return distinct values of a field, optionally filtered.
 * @param {String} table
 * @param {String|[String]} field
 * @param {String} where=null
 */
export const fetchDistinct = async (table, field, where = null) => {
  validateTable(table);
  const safeWhere = validateWhere(where);

  const fields = Array.isArray(field) ? field : [field];
  const safeFields = fields.map(validateField).join(", ");
  const whereClause = safeWhere ? ` WHERE ${safeWhere}` : "";
  const sqlStatement = `SELECT DISTINCT ${safeFields} FROM ${table}${whereClause}`;

  if (USE_SQLITE) {
    const db = await sqliteDbPromise;
    return db.all(sqlStatement);
  }

  return new Promise((resolve, reject) => {
    connection.query(sqlStatement, (error, results) => {
      if (error) reject(error);
      else resolve(results);
    });
  });
};

/**
 * Insert a new row into the given table.
 * @param {String} table
 * @param {Object} data  Key/value pairs of column → value (id is ignored).
 */
export const addData = async (table, data) => {
  validateTable(table);

  const columns = Object.keys(data)
    .filter((k) => k !== "id" && data[k] !== undefined && data[k] !== "")
    .map(validateField);
  const values = columns.map((c) => data[c]);
  const placeholders = columns.map(() => "?").join(", ");
  const sql = `INSERT INTO ${table} (${columns.join(", ")}) VALUES (${placeholders})`;

  if (USE_SQLITE) {
    const db = await sqliteDbPromise;
    const result = await db.run(sql, values);
    return { id: result.lastID };
  }

  return new Promise((resolve, reject) => {
    connection.query(sql, values, (error, results) => {
      if (error) reject(error);
      else resolve({ id: results.insertId });
    });
  });
};

// ---------------------------------------------------------------------------
// Internal helpers
// ---------------------------------------------------------------------------

/**
 * Converts raw DB field descriptors into the shape the frontend expects.
 * @param {Object|Array} fields
 */
const formatFields = async (fields) => {
  const fieldsTypeMap = new Map([
    ["int", "number"],
    ["tinyint", "number"],
    ["float", "number"],
    ["double", "number"],
    ["decimal", "number"],
    ["date", "date"],
    ["time", "time"],
    ["datetime", "datetime"],
    ["varchar", "text"],
    ["bigint", "text"],
    ["bit", "boolean"],
    ["nvarchar", "text"],
  ]);

  let frontendFields = [];
  let pendingPromises = [];

  // Object.values works correctly for both arrays (SQLite path) and plain
  // objects (MySQL path), replacing the previous for…in on an array.
  for (const field of Object.values(fields)) {
    let frontEndField = {};
    frontEndField.name = field.Field;
    frontEndField.displayText = camelCaseToLabel(frontEndField.name);
    frontEndField.required = field.Null === "NO";

    if (frontEndField.name.endsWith("Id")) {
      frontEndField.type = "dropdown";
      pendingPromises.push(
        getDropdownValues(frontEndField.name).then(
          (results) => (frontEndField.items = results)
        )
      );
      frontEndField.displayText = camelCaseToLabel(
        frontEndField.name.replace("Id", "")
      );
    }

    const type = field.Type;
    if (type.indexOf("(") !== -1) {
      frontEndField.type = fieldsTypeMap.get(
        type.substring(0, type.indexOf("("))
      );

      if (type.startsWith("decimal"))
        [frontEndField.length, frontEndField.decimals] = type
          .replace(/.*\((\d+),(\d+).*/g, "$1,$2")
          .split(",");
      else frontEndField.length = type.replace(/.*\((\d+).*/g, "$1");
    }

    if (type.indexOf(" ") !== -1) {
      frontEndField.type = fieldsTypeMap.get(
        type.substring(0, type.indexOf(" "))
      );
      if (frontEndField.type === "double")
        frontEndField.length = type.split(" ")[1];
    }

    if (!frontEndField.type) {
      frontEndField.type = fieldsTypeMap.get(type);
    }

    frontendFields.push(frontEndField);
  }

  await Promise.all(pendingPromises);
  return frontendFields;
};

/**
 * Fetches the dropdown option rows for a foreign-key field.
 * @param {String} tableName  e.g. "vendorId"
 */
const getDropdownValues = async (tableName) => {
  const dropdownsMap = new Map([
    [
      "vendor",
      { value: "id", text: "name", "data-description": "description" },
    ],
    ["orderStatus", { value: "id", text: "status" }],
    [
      "customer",
      {
        value: "id",
        text: "name",
        "data-email": "email",
        "data-contact": "contactName",
        "data-phone": "phone",
      },
    ],
    [
      "shippingCarrier",
      { value: "id", text: "name", estimatedCost: "estimatedCost" },
    ],
    [
      "inventory",
      {
        value: "id",
        text: "inventoryNumber",
        "data-quantity": "quantity",
        "data-unitprice": "unitPrice",
      },
    ],
  ]);

  let table = tableName.replace("Id", "");

  let fieldsArray = [];
  let items = dropdownsMap.get(table);
  for (const property in items) {
    fieldsArray.push(`${items[property]} as '${property}'`);
  }

  if (table !== "inventory") {
    table = pluralize.plural(table);
  }

  return fetchData(table, fieldsArray);
};

/**
 * `camelCaseToLabel` is imported from frontend shared utils.
 */

// Exported for use in tests only.
export { validateTable, validateField, validateWhere, sqliteDbPromise };
